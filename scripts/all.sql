
-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.aftercare_assessment
(
    assessment_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 3,
    completed_by_user_id integer,
    eval_hearing_aid_dead_broken integer,
    eval_hearing_aid_internal_feedback integer,
    eval_hearing_aid_power_change_needed integer,
    eval_hearing_aid_power_change_too_low integer,
    eval_hearing_aid_power_change_too_loud integer,
    eval_hearing_aid_lost_stolen integer,
    eval_hearing_aid_no_problem integer,
    eval_earmold_discomfort_too_tight integer,
    eval_earmold_feedback_too_loose integer,
    eval_earmold_damaged_tubing_cracked integer,
    eval_earmold_lost_stolen integer,
    eval_earmold_no_problem integer,
    service_tested_wfa_demo_hearing_aids integer,
    service_hearing_aid_sent_for_repair_replacement integer,
    service_not_benefiting_from_hearing_aid integer,
    service_refit_new_hearing_aid integer,
    service_retubed_unplugged_earmold integer,
    service_modified_earmold integer,
    service_fit_stock_earmold integer,
    service_took_new_ear_impression integer,
    service_refit_custom_earmold integer,
    gs_counseling boolean,
    gs_batteries_provided boolean,
    gs_batteries_13_qty integer,
    gs_batteries_675_qty integer,
    gs_refer_aftercare_service_center boolean,
    gs_refer_next_phase2_mission boolean,
    comment text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase3_reg_id integer,
    CONSTRAINT aftercare_assessment_pkey PRIMARY KEY (assessment_id)
);

CREATE TABLE IF NOT EXISTS public.audit_logs
(
    log_id serial NOT NULL,
    table_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    record_id integer NOT NULL,
    action_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    old_data jsonb,
    new_data jsonb,
    changed_by_user_id integer,
    change_timestamp timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT audit_logs_pkey PRIMARY KEY (log_id)
);

CREATE TABLE IF NOT EXISTS public.cities
(
    city_id serial NOT NULL,
    city_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    country_id integer NOT NULL,
    CONSTRAINT cities_pkey PRIMARY KEY (city_id),
    CONSTRAINT cities_city_name_country_id_key UNIQUE (city_name, country_id)
);

CREATE TABLE IF NOT EXISTS public.counseling
(
    counseling_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 2,
    completed_by_user_id integer,
    received_aftercare_information boolean,
    trained_as_student_ambassador boolean,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase2_reg_id integer,
    CONSTRAINT counseling_pkey PRIMARY KEY (counseling_id)
);

CREATE TABLE IF NOT EXISTS public.countries
(
    country_id serial NOT NULL,
    iso_code character varying(3) COLLATE pg_catalog."default",
    country_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT countries_pkey PRIMARY KEY (country_id),
    CONSTRAINT countries_country_name_key UNIQUE (country_name),
    CONSTRAINT countries_iso_code_key UNIQUE (iso_code)
);

CREATE TABLE IF NOT EXISTS public.ear_impressions
(
    impression_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 1,
    completed_by_user_id integer,
    ear_impression character varying(10) COLLATE pg_catalog."default",
    comment text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase1_reg_id integer,
    CONSTRAINT ear_impressions_pkey PRIMARY KEY (impression_id)
);

CREATE TABLE IF NOT EXISTS public.ear_screening
(
    ear_screening_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer NOT NULL,
    completed_by_user_id integer,
    screening_name character varying(50) COLLATE pg_catalog."default",
    ears_clear character varying(50) COLLATE pg_catalog."default",
    otc_wax integer,
    otc_infection integer,
    otc_perforation integer,
    otc_tinnitus integer,
    otc_atresia integer,
    otc_implant integer,
    otc_other integer,
    medical_recommendation character varying(50) COLLATE pg_catalog."default",
    medication_given text[] COLLATE pg_catalog."default",
    left_ear_clear_for_fitting character varying(50) COLLATE pg_catalog."default",
    right_ear_clear_for_fitting character varying(50) COLLATE pg_catalog."default",
    comments text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase1_reg_id integer,
    phase3_reg_id integer,
    phase2_reg_id integer,
    CONSTRAINT ear_screening_pkey PRIMARY KEY (ear_screening_id)
);

CREATE TABLE IF NOT EXISTS public.final_qc_p1
(
    final_qc_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 1,
    completed_by_user_id integer,
    ear_impressions_inspected_collected boolean,
    shf_id_number_id_card_given boolean,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase1_reg_id integer,
    CONSTRAINT final_qc_p1_pkey PRIMARY KEY (final_qc_id)
);

CREATE TABLE IF NOT EXISTS public.final_qc_p2
(
    final_qc_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 2,
    completed_by_user_id integer,
    batteries_provided_13 integer,
    batteries_provided_675 integer,
    hearing_aid_satisfaction_18_plus character varying(50) COLLATE pg_catalog."default",
    confirmation boolean,
    qc_comments text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase2_reg_id integer,
    CONSTRAINT final_qc_p2_pkey PRIMARY KEY (final_qc_id)
);

CREATE TABLE IF NOT EXISTS public.final_qc_p3
(
    final_qc_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 3,
    completed_by_user_id integer,
    hearing_aid_satisfaction_18_plus character varying(50) COLLATE pg_catalog."default",
    ask_people_to_repeat_themselves character varying(50) COLLATE pg_catalog."default",
    notes_from_shf text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase3_reg_id integer,
    CONSTRAINT final_qc_p3_pkey PRIMARY KEY (final_qc_id)
);

CREATE TABLE IF NOT EXISTS public.fitting
(
    fitting_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 2,
    fitter_id integer,
    number_of_hearing_aid integer,
    special_device character varying(100) COLLATE pg_catalog."default",
    normal_hearing integer,
    distortion integer,
    implant integer,
    recruitment integer,
    no_response integer,
    other integer,
    comment text COLLATE pg_catalog."default",
    clear_for_counseling boolean,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase2_reg_id integer,
    CONSTRAINT fitting_pkey PRIMARY KEY (fitting_id)
);

CREATE TABLE IF NOT EXISTS public.fitting_table
(
    fitting_table_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 2,
    fitter_id integer,
    fitting_left_power_level character varying(100) COLLATE pg_catalog."default",
    fitting_left_volume character varying(100) COLLATE pg_catalog."default",
    fitting_left_model character varying(100) COLLATE pg_catalog."default",
    fitting_left_battery character varying(50) COLLATE pg_catalog."default",
    fitting_left_earmold character varying(100) COLLATE pg_catalog."default",
    fitting_right_power_level character varying(100) COLLATE pg_catalog."default",
    fitting_right_volume character varying(100) COLLATE pg_catalog."default",
    fitting_right_model character varying(100) COLLATE pg_catalog."default",
    fitting_right_battery character varying(50) COLLATE pg_catalog."default",
    fitting_right_earmold character varying(100) COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase2_reg_id integer,
    CONSTRAINT fitting_table_pkey PRIMARY KEY (fitting_table_id)
);

CREATE TABLE IF NOT EXISTS public.hearing_screening
(
    hearing_screen_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer NOT NULL,
    completed_by_user_id integer,
    screening_method character varying(100) COLLATE pg_catalog."default",
    left_ear_result character varying(50) COLLATE pg_catalog."default",
    right_ear_result character varying(50) COLLATE pg_catalog."default",
    hearing_satisfaction_18_plus_pass character varying(50) COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phase1_reg_id integer,
    phase2_reg_id integer,
    CONSTRAINT hearing_screening_pkey PRIMARY KEY (hearing_screen_id)
);

CREATE TABLE IF NOT EXISTS public.mission_documents
(
    document_id serial NOT NULL,
    title character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default" NOT NULL,
    version integer NOT NULL,
    file_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    original_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    file_path character varying(500) COLLATE pg_catalog."default" NOT NULL,
    file_size integer NOT NULL,
    file_type character varying(100) COLLATE pg_catalog."default" NOT NULL,
    uploaded_by integer NOT NULL,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT mission_documents_pkey PRIMARY KEY (document_id)
);

CREATE TABLE IF NOT EXISTS public.otp_codes
(
    otp_id serial NOT NULL,
    user_id integer,
    otp_code character varying(10) COLLATE pg_catalog."default" NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    is_verified boolean DEFAULT false,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT otp_codes_pkey PRIMARY KEY (otp_id)
);

CREATE TABLE IF NOT EXISTS public.patient_archives
(
    archive_id serial NOT NULL,
    patient_id integer NOT NULL,
    archived_by_user_id integer,
    archived_at timestamp with time zone DEFAULT now(),
    snapshot jsonb NOT NULL,
    summary jsonb,
    CONSTRAINT patient_archives_pkey PRIMARY KEY (archive_id)
);

CREATE TABLE IF NOT EXISTS public.patient_phases
(
    patient_phase_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer NOT NULL,
    phase_start_date date NOT NULL,
    phase_end_date date,
    status character varying(50) COLLATE pg_catalog."default" NOT NULL DEFAULT 'In Progress'::character varying,
    completed_by_user_id integer,
    CONSTRAINT patient_phases_pkey PRIMARY KEY (patient_phase_id),
    CONSTRAINT patient_phases_patient_id_phase_id_key UNIQUE (patient_id, phase_id)
);

CREATE TABLE IF NOT EXISTS public.patients
(
    patient_id serial NOT NULL,
    shf_id character varying(50) COLLATE pg_catalog."default",
    last_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    first_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    gender character varying(50) COLLATE pg_catalog."default",
    date_of_birth date,
    age integer,
    mobile_number character varying(50) COLLATE pg_catalog."default",
    mobile_sms boolean,
    alternative_number character varying(50) COLLATE pg_catalog."default",
    alternative_sms boolean,
    region_district character varying(100) COLLATE pg_catalog."default",
    city_village character varying(100) COLLATE pg_catalog."default",
    highest_education_level character varying(100) COLLATE pg_catalog."default",
    employment_status character varying(100) COLLATE pg_catalog."default",
    school_name character varying(255) COLLATE pg_catalog."default",
    school_phone_number character varying(50) COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    is_student boolean,
    user_id integer,
    archived boolean DEFAULT false,
    last_active_date timestamp with time zone,
    status character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT patients_pkey PRIMARY KEY (patient_id),
    CONSTRAINT patients_shf_id_key UNIQUE (shf_id)
);

CREATE TABLE IF NOT EXISTS public.phase1_registration_section
(
    phase1_reg_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 1,
    registration_date date NOT NULL,
    city character varying(100) COLLATE pg_catalog."default",
    completed_by_user_id integer,
    has_hearing_loss character varying(50) COLLATE pg_catalog."default",
    uses_sign_language character varying(50) COLLATE pg_catalog."default",
    uses_speech character varying(50) COLLATE pg_catalog."default",
    hearing_loss_causes text[] COLLATE pg_catalog."default",
    ringing_sensation character varying(50) COLLATE pg_catalog."default",
    ear_pain character varying(50) COLLATE pg_catalog."default",
    hearing_satisfaction_18_plus character varying(50) COLLATE pg_catalog."default",
    conversation_difficulty character varying(50) COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT phase1_registration_section_pkey PRIMARY KEY (phase1_reg_id)
);

CREATE TABLE IF NOT EXISTS public.phase2_registration_section
(
    phase2_reg_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 2,
    registration_date date NOT NULL,
    city character varying(100) COLLATE pg_catalog."default",
    patient_type character varying(100) COLLATE pg_catalog."default",
    completed_by_user_id integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT phase2_registration_section_pkey PRIMARY KEY (phase2_reg_id)
);

CREATE TABLE IF NOT EXISTS public.phase3_registration_section
(
    phase3_reg_id serial NOT NULL,
    patient_id integer NOT NULL,
    phase_id integer DEFAULT 3,
    registration_date date NOT NULL,
    country character varying(100) COLLATE pg_catalog."default",
    city character varying(100) COLLATE pg_catalog."default",
    completed_by_user_id integer,
    type_of_aftercare character varying(100) COLLATE pg_catalog."default",
    service_center_school_name character varying(255) COLLATE pg_catalog."default",
    return_visit_custom_earmold_repair boolean,
    problem_with_hearing_aid_earmold character varying(50) COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT phase3_registration_section_pkey PRIMARY KEY (phase3_reg_id)
);

CREATE TABLE IF NOT EXISTS public.phases
(
    phase_id integer NOT NULL,
    phase_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    phase_description text COLLATE pg_catalog."default",
    CONSTRAINT phases_pkey PRIMARY KEY (phase_id)
);

CREATE TABLE IF NOT EXISTS public.roles
(
    role_id serial NOT NULL,
    role_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT roles_pkey PRIMARY KEY (role_id),
    CONSTRAINT roles_role_name_key UNIQUE (role_name)
);

CREATE TABLE IF NOT EXISTS public.schedules
(
    schedule_id serial NOT NULL,
    mission_name character varying(50) COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    aftercarecity character varying(100) COLLATE pg_catalog."default",
    date date NOT NULL,
    "time" time without time zone,
    status character varying(50) COLLATE pg_catalog."default",
    created_by_user_id integer,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT schedules_pkey PRIMARY KEY (schedule_id)
);

CREATE TABLE IF NOT EXISTS public.sms_messages
(
    sms_id serial NOT NULL,
    message_type character varying(50) COLLATE pg_catalog."default",
    message_content text COLLATE pg_catalog."default" NOT NULL,
    recipient_count integer DEFAULT 0,
    recipients text COLLATE pg_catalog."default",
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT sms_messages_pkey PRIMARY KEY (sms_id)
);

CREATE TABLE IF NOT EXISTS public.supplies
(
    supply_id serial NOT NULL,
    category_id integer NOT NULL,
    item_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    current_stock_level integer NOT NULL DEFAULT 0,
    unit_of_measure character varying(50) COLLATE pg_catalog."default",
    reorder_level integer DEFAULT 0,
    status character varying(50) COLLATE pg_catalog."default" NOT NULL DEFAULT 'Available'::character varying,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    item_code character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT supplies_pkey PRIMARY KEY (supply_id),
    CONSTRAINT supplies_item_code_key UNIQUE (item_code)
);

CREATE TABLE IF NOT EXISTS public.supply_categories
(
    category_id serial NOT NULL,
    category_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT supply_categories_pkey PRIMARY KEY (category_id),
    CONSTRAINT supply_categories_category_name_key UNIQUE (category_name)
);

CREATE TABLE IF NOT EXISTS public.supply_transaction_types
(
    transaction_type_id serial NOT NULL,
    type_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT supply_transaction_types_pkey PRIMARY KEY (transaction_type_id),
    CONSTRAINT supply_transaction_types_type_name_key UNIQUE (type_name)
);

CREATE TABLE IF NOT EXISTS public.supply_transactions
(
    transaction_id serial NOT NULL,
    supply_id integer NOT NULL,
    transaction_type_id integer NOT NULL,
    quantity integer NOT NULL,
    transaction_date timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    recorded_by_user_id integer,
    notes text COLLATE pg_catalog."default",
    patient_id integer,
    phase_id integer,
    related_event_type text COLLATE pg_catalog."default",
    CONSTRAINT supply_transactions_pkey PRIMARY KEY (transaction_id)
);

CREATE TABLE IF NOT EXISTS public.user_locations
(
    user_location_id serial NOT NULL,
    user_id integer NOT NULL,
    country_id integer,
    city_id integer,
    CONSTRAINT user_locations_pkey PRIMARY KEY (user_location_id)
);

CREATE TABLE IF NOT EXISTS public.user_roles
(
    user_id integer NOT NULL,
    role_id integer NOT NULL,
    CONSTRAINT user_roles_pkey PRIMARY KEY (user_id, role_id)
);

CREATE TABLE IF NOT EXISTS public.users
(
    user_id serial NOT NULL,
    username character varying(100) COLLATE pg_catalog."default" NOT NULL,
    password_hash character varying(255) COLLATE pg_catalog."default" NOT NULL,
    first_name character varying(100) COLLATE pg_catalog."default",
    last_name character varying(100) COLLATE pg_catalog."default",
    email character varying(255) COLLATE pg_catalog."default",
    is_active boolean DEFAULT true,
    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
    phone_number character varying(32) COLLATE pg_catalog."default",
    city_assigned character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT users_pkey PRIMARY KEY (user_id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_username_key UNIQUE (username)
);

ALTER TABLE IF EXISTS public.aftercare_assessment
    ADD CONSTRAINT aftercare_assessment_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.aftercare_assessment
    ADD CONSTRAINT aftercare_assessment_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_aftercare_assessment_patient_id
    ON public.aftercare_assessment(patient_id);


ALTER TABLE IF EXISTS public.aftercare_assessment
    ADD CONSTRAINT aftercare_assessment_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.aftercare_assessment
    ADD CONSTRAINT aftercare_phase3_reg_fk FOREIGN KEY (phase3_reg_id)
    REFERENCES public.phase3_registration_section (phase3_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_aftercare_p3_reg_id
    ON public.aftercare_assessment(phase3_reg_id);


ALTER TABLE IF EXISTS public.audit_logs
    ADD CONSTRAINT audit_logs_changed_by_user_id_fkey FOREIGN KEY (changed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.cities
    ADD CONSTRAINT cities_country_id_fkey FOREIGN KEY (country_id)
    REFERENCES public.countries (country_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.counseling
    ADD CONSTRAINT counseling_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.counseling
    ADD CONSTRAINT counseling_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_counseling_patient_id
    ON public.counseling(patient_id);


ALTER TABLE IF EXISTS public.counseling
    ADD CONSTRAINT counseling_phase2_reg_fk FOREIGN KEY (phase2_reg_id)
    REFERENCES public.phase2_registration_section (phase2_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_couns_p2_reg_id
    ON public.counseling(phase2_reg_id);


ALTER TABLE IF EXISTS public.counseling
    ADD CONSTRAINT counseling_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ear_impressions
    ADD CONSTRAINT ear_impressions_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ear_impressions
    ADD CONSTRAINT ear_impressions_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_ear_impressions_patient_id
    ON public.ear_impressions(patient_id);


ALTER TABLE IF EXISTS public.ear_impressions
    ADD CONSTRAINT ear_impressions_phase1_reg_id_fkey FOREIGN KEY (phase1_reg_id)
    REFERENCES public.phase1_registration_section (phase1_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_ear_impressions_phase1_reg_id
    ON public.ear_impressions(phase1_reg_id);


ALTER TABLE IF EXISTS public.ear_impressions
    ADD CONSTRAINT ear_impressions_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ear_screening
    ADD CONSTRAINT ear_screening_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.ear_screening
    ADD CONSTRAINT ear_screening_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_ear_screening_patient_id
    ON public.ear_screening(patient_id);


ALTER TABLE IF EXISTS public.ear_screening
    ADD CONSTRAINT ear_screening_phase1_reg_id_fkey FOREIGN KEY (phase1_reg_id)
    REFERENCES public.phase1_registration_section (phase1_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_ear_screening_phase1_reg_id
    ON public.ear_screening(phase1_reg_id);


ALTER TABLE IF EXISTS public.ear_screening
    ADD CONSTRAINT ear_screening_phase2_reg_fk FOREIGN KEY (phase2_reg_id)
    REFERENCES public.phase2_registration_section (phase2_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_es_p2_reg_id
    ON public.ear_screening(phase2_reg_id);


ALTER TABLE IF EXISTS public.ear_screening
    ADD CONSTRAINT ear_screening_phase3_reg_fk FOREIGN KEY (phase3_reg_id)
    REFERENCES public.phase3_registration_section (phase3_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_es_p3_reg_id
    ON public.ear_screening(phase3_reg_id);


ALTER TABLE IF EXISTS public.ear_screening
    ADD CONSTRAINT ear_screening_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.final_qc_p1
    ADD CONSTRAINT final_qc_p1_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.final_qc_p1
    ADD CONSTRAINT final_qc_p1_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_final_qc_p1_patient_id
    ON public.final_qc_p1(patient_id);


ALTER TABLE IF EXISTS public.final_qc_p1
    ADD CONSTRAINT final_qc_p1_phase1_reg_id_fkey FOREIGN KEY (phase1_reg_id)
    REFERENCES public.phase1_registration_section (phase1_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_final_qc_p1_phase1_reg_id
    ON public.final_qc_p1(phase1_reg_id);


ALTER TABLE IF EXISTS public.final_qc_p1
    ADD CONSTRAINT final_qc_p1_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.final_qc_p2
    ADD CONSTRAINT final_qc_p2_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.final_qc_p2
    ADD CONSTRAINT final_qc_p2_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_final_qc_p2_patient_id
    ON public.final_qc_p2(patient_id);


ALTER TABLE IF EXISTS public.final_qc_p2
    ADD CONSTRAINT final_qc_p2_phase2_reg_fk FOREIGN KEY (phase2_reg_id)
    REFERENCES public.phase2_registration_section (phase2_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_fqc2_p2_reg_id
    ON public.final_qc_p2(phase2_reg_id);


ALTER TABLE IF EXISTS public.final_qc_p2
    ADD CONSTRAINT final_qc_p2_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.final_qc_p3
    ADD CONSTRAINT final_qc_p3_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.final_qc_p3
    ADD CONSTRAINT final_qc_p3_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_final_qc_p3_patient_id
    ON public.final_qc_p3(patient_id);


ALTER TABLE IF EXISTS public.final_qc_p3
    ADD CONSTRAINT final_qc_p3_phase3_reg_fk FOREIGN KEY (phase3_reg_id)
    REFERENCES public.phase3_registration_section (phase3_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_fqc3_p3_reg_id
    ON public.final_qc_p3(phase3_reg_id);


ALTER TABLE IF EXISTS public.final_qc_p3
    ADD CONSTRAINT final_qc_p3_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.fitting
    ADD CONSTRAINT fitting_fitter_id_fkey FOREIGN KEY (fitter_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.fitting
    ADD CONSTRAINT fitting_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_fitting_patient_id
    ON public.fitting(patient_id);


ALTER TABLE IF EXISTS public.fitting
    ADD CONSTRAINT fitting_phase2_reg_fk FOREIGN KEY (phase2_reg_id)
    REFERENCES public.phase2_registration_section (phase2_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_fit_p2_reg_id
    ON public.fitting(phase2_reg_id);


ALTER TABLE IF EXISTS public.fitting
    ADD CONSTRAINT fitting_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.fitting_table
    ADD CONSTRAINT fitting_table_fitter_id_fkey FOREIGN KEY (fitter_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.fitting_table
    ADD CONSTRAINT fitting_table_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_fitting_table_patient_id
    ON public.fitting_table(patient_id);


ALTER TABLE IF EXISTS public.fitting_table
    ADD CONSTRAINT fitting_table_phase2_reg_fk FOREIGN KEY (phase2_reg_id)
    REFERENCES public.phase2_registration_section (phase2_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_fit_table_p2_reg_id
    ON public.fitting_table(phase2_reg_id);


ALTER TABLE IF EXISTS public.fitting_table
    ADD CONSTRAINT fitting_table_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.hearing_screening
    ADD CONSTRAINT hearing_screening_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.hearing_screening
    ADD CONSTRAINT hearing_screening_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_hearing_screening_patient_id
    ON public.hearing_screening(patient_id);


ALTER TABLE IF EXISTS public.hearing_screening
    ADD CONSTRAINT hearing_screening_phase1_reg_id_fkey FOREIGN KEY (phase1_reg_id)
    REFERENCES public.phase1_registration_section (phase1_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_hearing_screening_phase1_reg_id
    ON public.hearing_screening(phase1_reg_id);


ALTER TABLE IF EXISTS public.hearing_screening
    ADD CONSTRAINT hearing_screening_phase2_reg_fk FOREIGN KEY (phase2_reg_id)
    REFERENCES public.phase2_registration_section (phase2_reg_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_hs_p2_reg_id
    ON public.hearing_screening(phase2_reg_id);


ALTER TABLE IF EXISTS public.hearing_screening
    ADD CONSTRAINT hearing_screening_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.mission_documents
    ADD CONSTRAINT mission_documents_uploaded_by_fkey FOREIGN KEY (uploaded_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_mission_documents_uploaded_by
    ON public.mission_documents(uploaded_by);


ALTER TABLE IF EXISTS public.otp_codes
    ADD CONSTRAINT otp_codes_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.patient_phases
    ADD CONSTRAINT patient_phases_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.patient_phases
    ADD CONSTRAINT patient_phases_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_patient_phases_patient_id
    ON public.patient_phases(patient_id);


ALTER TABLE IF EXISTS public.patient_phases
    ADD CONSTRAINT patient_phases_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_patient_phases_phase_id
    ON public.patient_phases(phase_id);


ALTER TABLE IF EXISTS public.patients
    ADD CONSTRAINT user_id FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.phase1_registration_section
    ADD CONSTRAINT phase1_registration_section_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.phase1_registration_section
    ADD CONSTRAINT phase1_registration_section_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.phase1_registration_section
    ADD CONSTRAINT phase1_registration_section_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.phase2_registration_section
    ADD CONSTRAINT phase2_registration_section_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.phase2_registration_section
    ADD CONSTRAINT phase2_registration_section_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_phase2_reg_patient_id
    ON public.phase2_registration_section(patient_id);


ALTER TABLE IF EXISTS public.phase2_registration_section
    ADD CONSTRAINT phase2_registration_section_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.phase3_registration_section
    ADD CONSTRAINT phase3_registration_section_completed_by_user_id_fkey FOREIGN KEY (completed_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.phase3_registration_section
    ADD CONSTRAINT phase3_registration_section_patient_id_fkey FOREIGN KEY (patient_id)
    REFERENCES public.patients (patient_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_phase3_reg_patient_id
    ON public.phase3_registration_section(patient_id);


ALTER TABLE IF EXISTS public.phase3_registration_section
    ADD CONSTRAINT phase3_registration_section_phase_id_fkey FOREIGN KEY (phase_id)
    REFERENCES public.phases (phase_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.schedules
    ADD CONSTRAINT schedules_created_by_user_id_fkey FOREIGN KEY (created_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.supplies
    ADD CONSTRAINT supplies_category_id_fkey FOREIGN KEY (category_id)
    REFERENCES public.supply_categories (category_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_supplies_category
    ON public.supplies(category_id);


ALTER TABLE IF EXISTS public.supply_transactions
    ADD CONSTRAINT supply_transactions_recorded_by_user_id_fkey FOREIGN KEY (recorded_by_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.supply_transactions
    ADD CONSTRAINT supply_transactions_supply_id_fkey FOREIGN KEY (supply_id)
    REFERENCES public.supplies (supply_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_supply_transactions_supply
    ON public.supply_transactions(supply_id);


ALTER TABLE IF EXISTS public.supply_transactions
    ADD CONSTRAINT supply_transactions_transaction_type_id_fkey FOREIGN KEY (transaction_type_id)
    REFERENCES public.supply_transaction_types (transaction_type_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_supply_transactions_type
    ON public.supply_transactions(transaction_type_id);


ALTER TABLE IF EXISTS public.user_locations
    ADD CONSTRAINT user_locations_city_id_fkey FOREIGN KEY (city_id)
    REFERENCES public.cities (city_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.user_locations
    ADD CONSTRAINT user_locations_country_id_fkey FOREIGN KEY (country_id)
    REFERENCES public.countries (country_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.user_locations
    ADD CONSTRAINT user_locations_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_user_locations_user_id
    ON public.user_locations(user_id);


ALTER TABLE IF EXISTS public.user_roles
    ADD CONSTRAINT user_roles_role_id_fkey FOREIGN KEY (role_id)
    REFERENCES public.roles (role_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.user_roles
    ADD CONSTRAINT user_roles_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_user_roles_user_id
    ON public.user_roles(user_id);

END;